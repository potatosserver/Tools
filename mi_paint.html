<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>專業繪圖板 (支援縮放與平移)</title>
    <!-- 載入 Lucide Icons for aesthetic buttons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'surface': '#F7F2F9',
                        'on-surface': '#1C1B1F',
                        'primary': '#6750A4',
                        'primary-container': '#EADDFF',
                        'on-primary': '#FFFFFF',
                        'error': '#B3261E',
                        'canvas-bg': '#ffffff', // 畫布背景色
                    },
                }
            }
        }
    </script>
    <style>
        /* 確保全屏和 Inter 字體 */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #F7F2F9; /* M3 Surface */
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* 主要佈局 */
        #appLayout {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            padding: 1rem;
        }


        /* Canvas 容器樣式 */
        #canvasContainer {
            flex-grow: 1;
            position: relative;
            background-color: var(--tw-colors-canvas-bg);
            border-radius: 1.5rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        #drawingCanvas {
            touch-action: none; /* 禁用瀏覽器的預設觸控手勢 */
        }

        .canvas-responsive {
            display: block;
            width: 100%;
            height: 100%;
        }


        /* 筆刷/橡皮擦游標指示器 */
        #brushCursor {
            position: absolute;
            transform: translate(-50%, -50%); /* 居中游標 */
            pointer-events: none; /* 允許點擊穿透 */
            z-index: 1000;
            border-style: dashed;
        }

        /* M3 Tool Button Styling */
        .tool-button {
            padding: 0.75rem;
            border-radius: 9999px;
            transition: all 0.2s;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            background-color: #f0f0f0;
            color: var(--tw-colors-on-surface);
            display: flex; /* Ensure icon is centered */
            align-items: center;
            justify-content: center;
        }
        
        .tool-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            box-shadow: none;
        }

        .tool-button.active {
            background-color: var(--tw-colors-primary);
            color: var(--tw-colors-on-primary);
            box-shadow: 0 4px 6px rgba(103, 80, 164, 0.4);
        }

        /* 選取工具的浮動控制項 - 增強對比度 */
        #selectionControls {
            position: absolute;
            z-index: 200;
            padding: 0.5rem 1rem;
            background-color: rgb(31, 41, 55); /* Tailwind gray-800 */
            color: white;
            border-radius: 9999px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            display: none; /* 預設隱藏 */
            min-width: 200px;
            justify-content: space-around;
        }

        #selectionControls button {
            background: none;
            border: none;
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 9999px;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        #selectionControls button:hover {
            background-color: rgba(255, 255, 255, 0.15); /* 輕微高亮 */
        }


        /* Toggle switch style */
        .toggle-switch-container {
            display: inline-block;
            cursor: pointer;
            position: relative;
        }

        .toggle-track {
            width: 44px;
            height: 24px;
            background-color: #8E8E93; /* Off state */
            border-radius: 12px;
            padding: 2px;
            transition: background-color 0.2s;
        }

        .toggle-handle {
            width: 20px;
            height: 20px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.2s;
        }
        
        #palmRejectionToggle:checked+.toggle-track {
            background-color: #22C55E; /* Tailwind green-500 */
        }

        #palmRejectionToggle:checked+.toggle-track .toggle-handle {
            transform: translateX(20px);
        }
        
        /* Toolbar scrolling optimization */
        .toolbar-scroll-container {
            display: flex;
            align-items: center;
            overflow-x: auto;
            overflow-y: hidden;
            flex-grow: 1;
            min-width: 0; /* Important for flex child to shrink */
        }
        .toolbar-scroll-container::-webkit-scrollbar {
            display: none; /* Hide scrollbar for Chrome, Safari and Opera */
        }
        .toolbar-scroll-container {
            -ms-overflow-style: none; /* IE and Edge */
            scrollbar-width: none; /* Firefox */
        }

        /* --- 現代化顏色選擇器樣式 --- */
        #colorPickerModal { animation: fadeIn 0.3s ease-out; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        .color-swatch { width: 2.25rem; height: 2.25rem; border-radius: 9999px; cursor: pointer; border: 2px solid transparent; transition: all 0.2s; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .color-swatch:hover { transform: scale(1.1); }
        .color-swatch.selected { border-color: var(--tw-colors-primary); box-shadow: 0 0 0 2px white, 0 0 0 4px var(--tw-colors-primary); }
        
        #pickerContainer {
            position: relative;
            width: 100%;
            max-width: 280px;
            aspect-ratio: 1 / 1;
            margin: 0 auto;
        }
        #circularColorPickerCanvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
            touch-action: none;
        }
        .picker-indicator {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            transform: translate(-50%, -50%);
        }
        #slIndicator {
            width: 20px;
            height: 20px;
        }
        #hueIndicator {
            width: 30px;
            height: 30px;
        }

        /* Settings Modal Styling */
        .settings-modal-select {
            background-color: #EADDFF;
            color: #1C1B1F;
            border: 1px solid #6750A4;
            border-radius: 8px;
            padding: 8px 12px;
            width: 100%;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%236750A4' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 1em;
            padding-right: 2.5rem;
        }
    </style>
</head>
<body>

    <div id="appLayout">
        <!-- 頂部工具列 -->
        <div id="topToolbar" class="flex items-center gap-4 mb-4">
            <h1 class="text-xl font-bold text-primary whitespace-nowrap hidden lg:block">專業繪圖板</h1>
            
            <!-- Scrollable container for all tools -->
            <div class="toolbar-scroll-container">
                <!-- 工具選擇區 (繪圖/橡皮擦/選取) -->
                <div id="mainTools" class="flex items-center space-x-2 flex-shrink-0">
                    <button id="tool_pen" class="tool-button" data-tool="pen" title="繪圖模式 (鉛筆圖標)">
                        <i data-lucide="pencil" class="w-5 h-5"></i>
                    </button>
                    <button id="tool_eraser" class="tool-button" data-tool="eraser" title="橡皮擦/刪除模式 (橡皮圖標)">
                        <i data-lucide="eraser" class="w-5 h-5"></i>
                    </button>
                    <button id="tool_select" class="tool-button" data-tool="select" title="選取工具 (套索自由選取)">
                        <i data-lucide="lasso" class="w-5 h-5"></i>
                    </button>
                </div>

                <!-- 筆刷模式細項 -->
                <div id="brushOptions" class="flex items-center space-x-3 border-l ml-4 pl-4 hidden flex-shrink-0">
                    <span class="text-sm font-medium text-gray-700">筆刷類型：</span>
                    <button class="tool-button text-primary active" data-brush="fountain" title="鋼筆 (隨壓力變化) (Feather圖標)">
                        <i data-lucide="feather" class="w-5 h-5"></i>
                    </button>
                    <button class="tool-button text-primary" data-brush="ballpoint" title="圓珠筆 (固定寬度) (Circle-dot圖標)">
                        <i data-lucide="circle-dot" class="w-5 h-5"></i>
                    </button>
                    <button class="tool-button text-primary" data-brush="highlighter" title="螢光筆 (半透明固定寬度) (Highlighter圖標)">
                        <i data-lucide="highlighter" class="w-5 h-5"></i>
                    </button>
                </div>

                <!-- 橡皮擦/刪除模式細項 -->
                <div id="eraseControls" class="flex items-center space-x-3 border-l ml-4 pl-4 hidden flex-shrink-0">
                    <span class="text-sm font-medium text-gray-700">擦除模式：</span>
                    <button class="tool-button text-primary active" data-eraser="round" title="圓形硬邊橡皮擦 (繪圖擦除) (Eraser圖標)">
                        <i data-lucide="eraser" class="w-5 h-5"></i>
                    </button>
                    <button class="tool-button text-primary" data-eraser="rect_delete" title="矩形框選刪除筆畫 (虛線框圖標)">
                        <i data-lucide="square-dashed" class="w-5 h-5"></i>
                    </button>
                </div>

                <!-- 顏色與大小/透明度控制 (根據工具切換隱藏/顯示) -->
                <div id="drawingSettings" class="flex items-center space-x-4 border-l ml-4 pl-4 flex-shrink-0">
                    <!-- 顏色選取器 -->
                    <div id="colorContainer" class="relative w-9 h-9 flex items-center justify-center cursor-pointer" title="選擇顏色">
                        <div id="colorPreview" class="w-full h-full rounded-full border-2 border-gray-300 shadow-sm transition-transform hover:scale-110" style="background-color: #6750A4;"></div>
                    </div>
                    <!-- 筆刷大小 -->
                    <div class="flex items-center space-x-3 w-40 sm:w-48">
                        <label for="brushSize" class="text-sm font-medium text-gray-700 whitespace-nowrap">大小 (<span id="sizeValue">5</span>)</label>
                        <input type="range" id="brushSize" min="1" max="100" value="5" class="w-full accent-primary cursor-pointer transition">
                    </div>
                    <!-- 自訂透明度滑桿 -->
                    <div id="opacityContainer" class="flex items-center space-x-3 w-40 sm:w-48">
                        <label for="opacityRange" class="text-sm font-medium text-gray-700 whitespace-nowrap">透明度 (<span id="opacityValue">100%</span>)</label>
                        <input type="range" id="opacityRange" min="1" max="100" value="100" class="w-full accent-primary cursor-pointer transition">
                    </div>
                </div>

                <!-- 功能按鈕 (Undo, Redo, Clear) - Pushed to the end -->
                 <div class="flex items-center space-x-2 border-l ml-4 pl-4 ml-auto flex-shrink-0">
                    <!-- Undo/Redo Buttons -->
                    <button id="undoButton" class="tool-button" title="復原 (Undo)">
                        <i data-lucide="rotate-ccw" class="w-5 h-5"></i>
                    </button>
                    <button id="redoButton" class="tool-button" title="取消復原 (Redo)">
                        <i data-lucide="rotate-cw" class="w-5 h-5"></i>
                    </button>
                    <!-- Settings Button -->
                    <button id="settingsButton" class="tool-button" title="設定">
                        <i data-lucide="settings" class="w-5 h-5"></i>
                    </button>

                    <!-- 清除按鈕 -->
                    <button id="clearButton" class="tool-button bg-error text-white hover:bg-red-600" title="清除所有繪圖 (無法復原)">
                        <i data-lucide="trash-2" class="w-5 h-5"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- 繪圖容器 -->
        <div id="canvasContainer">
            <canvas id="drawingCanvas" class="canvas-responsive"></canvas>
            <div id="brushCursor" class="absolute pointer-events-none rounded-full border-2 border-dashed" style="display: none; border-color: rgba(0, 0, 0, 0.6);"></div>
            <div id="selectionControls" class="flex space-x-2">
                <button id="deleteSelectionBtn" title="刪除選取區域內的元素">
                    <i data-lucide="trash-2" class="w-5 h-5"></i>刪除
                </button>
                <button id="copySelectionBtn" title="複製選取的元素">
                    <i data-lucide="copy" class="w-5 h-5"></i>複製
                </button>
            </div>
        </div>
    </div>

    <div id="zoomIndicator" class="fixed bottom-6 right-6 bg-black/60 text-white text-sm rounded-full px-3 py-1 pointer-events-none transition-opacity duration-300 opacity-0 z-10">
        100%
    </div>

    <!-- Custom Confirmation Modal -->
    <div id="customConfirmModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-[9999]" style="display: none;">
        <div class="bg-surface rounded-3xl p-6 w-full max-w-sm shadow-2xl animate-fade-in">
            <h2 id="confirmTitle" class="text-2xl font-semibold text-on-surface mb-4"></h2>
            <p id="confirmMessage" class="text-on-surface mb-6"></p>
            <div class="flex justify-end space-x-4">
                <button id="confirmCancelBtn" class="px-6 py-2 rounded-full text-primary font-medium hover:bg-primary-container transition-colors">取消</button>
                <button id="confirmOkBtn" class="px-6 py-2 rounded-full bg-primary text-on-primary font-medium hover:bg-opacity-90 transition-colors shadow-md">確定</button>
            </div>
        </div>
    </div>

    <!-- 現代化顏色選擇器 Modal -->
    <div id="colorPickerModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-[9998]" style="display: none;">
        <div class="bg-surface rounded-3xl w-full max-w-sm shadow-2xl flex flex-col max-h-[90vh]">
            <h2 class="text-2xl font-semibold text-on-surface p-6 pb-4 flex-shrink-0">選擇顏色</h2>
            <div class="px-6 space-y-5 overflow-y-auto">
                <div>
                    <p class="text-sm font-medium text-on-surface mb-3">預設調色盤</p>
                    <div id="colorSwatches" class="grid grid-cols-6 gap-3"></div>
                </div>
                <div>
                    <p class="text-sm font-medium text-on-surface mb-3">自訂顏色</p>
                    <div id="pickerContainer">
                        <canvas id="circularColorPickerCanvas"></canvas>
                        <div id="slIndicator" class="picker-indicator"></div>
                        <div id="hueIndicator" class="picker-indicator"></div>
                    </div>
                </div>
            </div>
            <div class="p-6 pt-5 mt-auto flex-shrink-0 space-y-5">
                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-3">
                        <div id="colorPickerPreview" class="w-10 h-10 rounded-full border-2 border-gray-300"></div>
                        <input type="text" id="hexInput" class="w-28 text-center font-mono bg-primary-container text-primary rounded-full px-3 py-1.5 focus:outline-none focus:ring-2 focus:ring-primary">
                    </div>
                </div>
                <div class="flex justify-end space-x-4">
                    <button id="colorPickerCancelBtn" class="px-6 py-2 rounded-full text-primary font-medium hover:bg-primary-container transition-colors">取消</button>
                    <button id="colorPickerOkBtn" class="px-6 py-2 rounded-full bg-primary text-on-primary font-medium hover:bg-opacity-90 transition-colors shadow-md">確定</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Stylus Settings Modal -->
    <div id="stylusSettingsModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-[9999]" style="display: none;">
        <div class="bg-surface rounded-3xl p-6 w-full max-w-md shadow-2xl space-y-6">
            <h2 class="text-2xl font-semibold text-on-surface">畫筆設定</h2>
            
            <div class="space-y-4">
                <div>
                    <label for="primaryButtonSelect" class="block text-sm font-medium text-on-surface mb-2">主鍵 (速記鍵)</label>
                    <select id="primaryButtonSelect" class="settings-modal-select">
                        <option value="none">無動作</option>
                        <option value="eraser">與畫筆切換橡皮擦</option>
                        <option value="select">與畫筆切換套索</option>
                        <option value="previousColor">切換最近顏色</option>
                    </select>
                </div>
                <div>
                    <label for="secondaryButtonSelect" class="block text-sm font-medium text-on-surface mb-2">副鍵 (截圖鍵)</label>
                    <select id="secondaryButtonSelect" class="settings-modal-select">
                        <option value="none">無動作</option>
                        <option value="eraser">與畫筆切換橡皮擦</option>
                        <option value="select">與畫筆切換套索</option>
                        <option value="previousColor">切換最近顏色</option>
                    </select>
                </div>
            </div>
            
            <div class="flex items-center justify-between p-3 bg-primary-container/50 rounded-lg">
                <div class="flex items-center gap-3">
                    <i data-lucide="hand" class="w-5 h-5 text-on-surface"></i>
                    <span class="font-medium text-on-surface">防誤觸模式</span>
                </div>
                <label class="toggle-switch-container" for="palmRejectionToggle" title="切換單指輸入：忽略（防誤觸）或繪圖/選取">
                    <input type="checkbox" id="palmRejectionToggle" class="hidden" checked>
                    <div class="toggle-track"><div class="toggle-handle"></div></div>
                </label>
            </div>

            <div class="flex justify-end">
                <button id="saveSettingsBtn" class="px-6 py-2 rounded-full bg-primary text-on-primary font-medium hover:bg-opacity-90 transition-colors shadow-md">儲存並關閉</button>
            </div>
        </div>
    </div>


    <script>
        // ------------------ 設定與狀態 ------------------
        const canvas = document.getElementById('drawingCanvas');
        const container = document.getElementById('canvasContainer');
        const ctx = canvas.getContext('2d');
        
        const offscreenCanvas = document.createElement('canvas');
        const offscreenCtx = offscreenCanvas.getContext('2d');

        const brushCursor = document.getElementById('brushCursor');
        const brushSizeInput = document.getElementById('brushSize');
        const opacityRangeInput = document.getElementById('opacityRange');
        const palmRejectionToggle = document.getElementById('palmRejectionToggle');
        const selectionControls = document.getElementById('selectionControls');
        const sizeValueSpan = document.getElementById('sizeValue');
        const opacityValueSpan = document.getElementById('opacityValue');
        
        const colorPreview = document.getElementById('colorPreview');
        const colorContainer = document.getElementById('colorContainer');

        const opacityContainer = document.getElementById('opacityContainer');
        const brushOptionsDiv = document.getElementById('brushOptions');
        const eraseControlsDiv = document.getElementById('eraseControls');
        const clearButton = document.getElementById('clearButton');
        const undoButton = document.getElementById('undoButton');
        const redoButton = document.getElementById('redoButton');
        const settingsButton = document.getElementById('settingsButton');
        
        const zoomIndicator = document.getElementById('zoomIndicator');
        let zoomTimeout = null;

        const customConfirmModal = document.getElementById('customConfirmModal');
        const confirmTitle = document.getElementById('confirmTitle');
        const confirmMessage = document.getElementById('confirmMessage');
        const confirmCancelBtn = document.getElementById('confirmCancelBtn');
        const confirmOkBtn = document.getElementById('confirmOkBtn');

        const colorPickerModal = document.getElementById('colorPickerModal');
        const colorSwatchesContainer = document.getElementById('colorSwatches');
        const colorPickerPreview = document.getElementById('colorPickerPreview');
        const hexInput = document.getElementById('hexInput');
        const colorPickerCancelBtn = document.getElementById('colorPickerCancelBtn');
        const colorPickerOkBtn = document.getElementById('colorPickerOkBtn');
        
        // --- NEW Color Picker Elements ---
        const colorPickerCanvas = document.getElementById('circularColorPickerCanvas');
        const colorPickerCtx = colorPickerCanvas.getContext('2d');
        const slIndicator = document.getElementById('slIndicator');
        const hueIndicator = document.getElementById('hueIndicator');
        const pickerContainer = document.getElementById('pickerContainer');
        let tempColor = { h: 255, s: 70, l: 60 };

        const stylusSettingsModal = document.getElementById('stylusSettingsModal');
        const primaryButtonSelect = document.getElementById('primaryButtonSelect');
        const secondaryButtonSelect = document.getElementById('secondaryButtonSelect');
        const saveSettingsBtn = document.getElementById('saveSettingsBtn');
        
        let primaryButtonAction = 'none';
        let secondaryButtonAction = 'none';
        let previousColor = '#000000';

        const CANVAS_BACKGROUND_COLOR = '#ffffff';
        const SELECTION_BLUE = '#2196F3';
        const MIN_SCALE = 0.1;
        const MAX_SCALE = 10.0;
        const MAX_HISTORY_STATES = 50;

        let strokes = [];
        let historyStack = [];
        let redoStack = [];
        let recordingPath = [];
        let lassoPath = [];
        let selectedStrokes = new Set();
        let selectionActive = false;
        let selectionBoundaryPolygon = null;
        let selectionBounds = null;
        let isDrawing = false;
        let isSelecting = false;
        let isMovingSelected = false;

        let isRectSelecting = false;
        let rectStartPoint = null;
        let rectCurrentPoint = null;

        let scale = 1.0;
        let canvasOffsetX = 0;
        let canvasOffsetY = 0;
        
        let activePointers = new Map();
        let isPanningOrZooming = false;
        let initialPinchDistance = 0;
        let initialMidPoint = { x: 0, y: 0 };

        let currentColor = '#6750A4';
        let currentBrushSize = parseInt(brushSizeInput.value);
        let currentOpacity = parseInt(opacityRangeInput.value) / 100;
        let isPalmRejectionEnabled = palmRejectionToggle.checked;
        let currentTool = 'pen';
        let currentBrushType = 'fountain';
        let currentEraseMode = 'round';

        let toolSettings = {
            fountain: { color: '#6750A4', size: 5, opacity: 1.0 },
            ballpoint: { color: '#000000', size: 8, opacity: 1.0 },
            highlighter: { color: '#FFD700', size: 30, opacity: 0.3 },
            round: { color: CANVAS_BACKGROUND_COLOR, size: 20, opacity: 1.0 },
            rect_delete: { size: 10, opacity: 1.0 },
        };
        
        function showCustomConfirm(title, message) {
            return new Promise(resolve => {
                confirmTitle.textContent = title;
                confirmMessage.textContent = message;
                customConfirmModal.style.display = 'flex';
                const handleConfirm = () => { cleanup(); resolve(true); };
                const handleCancel = () => { cleanup(); resolve(false); };
                const cleanup = () => {
                    customConfirmModal.style.display = 'none';
                    confirmOkBtn.removeEventListener('click', handleConfirm);
                    confirmCancelBtn.removeEventListener('click', handleCancel);
                };
                confirmOkBtn.addEventListener('click', handleConfirm, { once: true });
                confirmCancelBtn.addEventListener('click', handleCancel, { once: true });
            });
        }
        
        // --- MERGED & UPDATED Color Picker Logic ---
        function hexToRgb(hex) {
            let r = 0, g = 0, b = 0;
            if (hex.length == 4) { r = parseInt(hex[1] + hex[1], 16); g = parseInt(hex[2] + hex[2], 16); b = parseInt(hex[3] + hex[3], 16); }
            else if (hex.length == 7) { r = parseInt(hex[1] + hex[2], 16); g = parseInt(hex[3] + hex[4], 16); b = parseInt(hex[5] + hex[6], 16); }
            return { r, g, b };
        }
        function rgbToHex(r, g, b) { return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase(); }
        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255; const max = Math.max(r, g, b), min = Math.min(r, g, b); let h = 0, s, l = (max + min) / 2;
            if (max === min) { h = s = 0; }
            else { const d = max - min; s = l > 0.5 ? d / (2 - max - min) : d / (max + min); switch (max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; } h /= 6; }
            return { h: h * 360, s: s * 100, l: l * 100 };
        }
        function hslToRgb(h, s, l) {
            s /= 100; l /= 100; let c = (1 - Math.abs(2 * l - 1)) * s, x = c * (1 - Math.abs((h / 60) % 2 - 1)), m = l - c / 2, r = 0, g = 0, b = 0;
            if (0 <= h && h < 60) { r = c; g = x; b = 0; } else if (60 <= h && h < 120) { r = x; g = c; b = 0; } else if (120 <= h && h < 180) { r = 0; g = c; b = x; } else if (180 <= h && h < 240) { r = 0; g = x; b = c; } else if (240 <= h && h < 300) { r = x; g = 0; b = c; } else if (300 <= h && h < 360) { r = c; g = 0; b = x; }
            r = Math.round((r + m) * 255); g = Math.round((g + m) * 255); b = Math.round((b + m) * 255);
            return { r, g, b };
        }
        
        let pickerWidth, pickerHeight, pickerCenterX, pickerCenterY, pickerOuterRadius, pickerInnerRadius, pickerSlBoxSize, pickerSlBoxOffset;

        function resizeColorPicker() {
            const dpr = window.devicePixelRatio || 1;
            const rect = colorPickerCanvas.getBoundingClientRect();
            colorPickerCanvas.width = rect.width * dpr;
            colorPickerCanvas.height = rect.height * dpr;
            colorPickerCtx.scale(dpr, dpr);
            
            pickerWidth = rect.width; pickerHeight = rect.height;
            pickerCenterX = pickerWidth / 2; pickerCenterY = pickerHeight / 2;
            pickerOuterRadius = pickerWidth / 2 - 5;
            pickerInnerRadius = pickerWidth / 2 - 35;
            pickerSlBoxSize = (pickerInnerRadius * 2) / Math.sqrt(2) - 10;
            pickerSlBoxOffset = -pickerSlBoxSize / 2;

            drawCircularPicker();
            updateCircularPickerUI();
        }

        function drawCircularPicker() {
            colorPickerCtx.clearRect(0, 0, pickerWidth, pickerHeight);
            for (let i = 0; i < 360; i++) {
                colorPickerCtx.beginPath();
                colorPickerCtx.strokeStyle = `hsl(${i}, 100%, 50%)`;
                colorPickerCtx.lineWidth = pickerOuterRadius - pickerInnerRadius;
                const angle = (i - 90) * (Math.PI / 180);
                colorPickerCtx.arc(pickerCenterX, pickerCenterY, (pickerOuterRadius + pickerInnerRadius) / 2, angle, angle + (Math.PI / 180) * 1.2);
                colorPickerCtx.stroke();
            }
            const hueColor = `hsl(${tempColor.h}, 100%, 50%)`;
            const gradWhite = colorPickerCtx.createLinearGradient(0, 0, pickerSlBoxSize, 0);
            gradWhite.addColorStop(0, 'white'); gradWhite.addColorStop(1, hueColor);
            colorPickerCtx.save();
            colorPickerCtx.translate(pickerCenterX + pickerSlBoxOffset, pickerCenterY + pickerSlBoxOffset);
            colorPickerCtx.fillStyle = gradWhite;
            colorPickerCtx.fillRect(0, 0, pickerSlBoxSize, pickerSlBoxSize);
            const gradBlack = colorPickerCtx.createLinearGradient(0, 0, 0, pickerSlBoxSize);
            gradBlack.addColorStop(0, 'rgba(0,0,0,0)'); gradBlack.addColorStop(1, 'black');
            colorPickerCtx.fillStyle = gradBlack;
            colorPickerCtx.fillRect(0, 0, pickerSlBoxSize, pickerSlBoxSize);
            colorPickerCtx.restore();
        }

        function updateCircularPickerUI() {
            const { r, g, b } = hslToRgb(tempColor.h, tempColor.s, tempColor.l); const hex = rgbToHex(r, g, b);
            colorPickerPreview.style.backgroundColor = hex; hexInput.value = hex;
            const slX = pickerCenterX + pickerSlBoxOffset + (tempColor.s / 100) * pickerSlBoxSize;
            const slY = pickerCenterY + pickerSlBoxOffset + (1 - tempColor.l / 100) * pickerSlBoxSize;
            slIndicator.style.left = `${(slX / pickerWidth) * 100}%`; slIndicator.style.top = `${(slY / pickerHeight) * 100}%`; slIndicator.style.backgroundColor = hex;
            const hueAngle = tempColor.h * (Math.PI / 180); const hueRadius = (pickerOuterRadius + pickerInnerRadius) / 2;
            const hueX = pickerCenterX + hueRadius * Math.cos(hueAngle - Math.PI / 2);
            const hueY = pickerCenterY + hueRadius * Math.sin(hueAngle - Math.PI / 2);
            hueIndicator.style.left = `${(hueX / pickerWidth) * 100}%`; hueIndicator.style.top = `${(hueY / pickerHeight) * 100}%`; hueIndicator.style.backgroundColor = `hsl(${tempColor.h}, 100%, 50%)`;
            document.querySelectorAll('.color-swatch').forEach(sw => { sw.classList.toggle('selected', sw.dataset.color.toUpperCase() === hex.toUpperCase()); });
        }
        
        let pickerActiveDrag = null;
        function handleColorPickerPointerEvent(e) {
            const rect = colorPickerCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left; const y = e.clientY - rect.top;
            const dx = x - pickerCenterX; const dy = y - pickerCenterY; const dist = Math.hypot(dx, dy);

            if (pickerActiveDrag === 'hue' || (pickerActiveDrag === null && dist >= pickerInnerRadius && dist <= pickerOuterRadius)) {
                const angle = Math.atan2(dy, dx) * (180 / Math.PI) + 90;
                tempColor.h = (angle + 360) % 360;
                drawCircularPicker(); updateCircularPickerUI();
            } else if (pickerActiveDrag === 'sl' || (pickerActiveDrag === null && Math.abs(dx) < pickerSlBoxSize/2 && Math.abs(dy) < pickerSlBoxSize/2)) {
                const slX = Math.max(0, Math.min(x - (pickerCenterX + pickerSlBoxOffset), pickerSlBoxSize));
                const slY = Math.max(0, Math.min(y - (pickerCenterY + pickerSlBoxOffset), pickerSlBoxSize));
                tempColor.s = (slX / pickerSlBoxSize) * 100;
                tempColor.l = (1 - slY / pickerSlBoxSize) * 100;
                updateCircularPickerUI();
            }
        }

        const PRESET_COLORS = ['#000000', '#FFFFFF', '#EF4444', '#F97316', '#EAB308', '#84CC16', '#22C55E', '#14B8A6', '#06B6D4', '#3B82F6', '#6366F1', '#8B5CF6'];
        
        function openColorPicker() {
            const {r,g,b} = hexToRgb(currentColor);
            tempColor = rgbToHsl(r,g,b);
            colorPickerModal.style.display = 'flex';
            requestAnimationFrame(resizeColorPicker);
        }
        function closeColorPicker() { colorPickerModal.style.display = 'none'; }
        function confirmColorChoice() {
            const { r, g, b } = hslToRgb(tempColor.h, tempColor.s, tempColor.l);
            const newHex = rgbToHex(r,g,b);
            if (currentColor !== newHex) { previousColor = currentColor; currentColor = newHex; }
            colorPreview.style.backgroundColor = currentColor; const key = getCurrentSettingKey(); if (key) toolSettings[key].color = currentColor;
            closeColorPicker();
        }

        function initializeColorPicker() {
            PRESET_COLORS.forEach(color => {
                const swatch = document.createElement('div'); swatch.className = 'color-swatch'; swatch.style.backgroundColor = color; swatch.dataset.color = color;
                swatch.addEventListener('click', () => {
                    const {r, g, b} = hexToRgb(color); tempColor = rgbToHsl(r,g,b);
                    drawCircularPicker(); updateCircularPickerUI();
                });
                colorSwatchesContainer.appendChild(swatch);
            });

            colorContainer.addEventListener('click', openColorPicker);
            colorPickerOkBtn.addEventListener('click', confirmColorChoice);
            colorPickerCancelBtn.addEventListener('click', closeColorPicker);
            
            hexInput.addEventListener('change', (e) => {
                 if (/^#[0-9A-F]{6}$/i.test(e.target.value) || /^#[0-9A-F]{3}$/i.test(e.target.value)) {
                    const {r, g, b} = hexToRgb(e.target.value); tempColor = rgbToHsl(r,g,b);
                    drawCircularPicker(); updateCircularPickerUI();
                 }
            });

            colorPickerCanvas.addEventListener('pointerdown', (e) => {
                colorPickerCanvas.setPointerCapture(e.pointerId);
                const rect = colorPickerCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left; const y = e.clientY - rect.top;
                const dx = x - pickerCenterX; const dy = y - pickerCenterY; const dist = Math.hypot(dx, dy);
                if (dist >= pickerInnerRadius && dist <= pickerOuterRadius) { pickerActiveDrag = 'hue'; } 
                else if (Math.abs(dx) < pickerSlBoxSize/2 && Math.abs(dy) < pickerSlBoxSize/2) { pickerActiveDrag = 'sl'; }
                handleColorPickerPointerEvent(e);
            });
            colorPickerCanvas.addEventListener('pointermove', (e) => {
                if (pickerActiveDrag) { handleColorPickerPointerEvent(e); }
            });
            colorPickerCanvas.addEventListener('pointerup', (e) => {
                colorPickerCanvas.releasePointerCapture(e.pointerId);
                pickerActiveDrag = null;
            });

            new ResizeObserver(resizeColorPicker).observe(pickerContainer);
        }

        // ... [The rest of the main application code is unchanged] ...

        // ------------------ 復原/取消復原 邏輯 ------------------
        function deepCopyStrokes(strokesArray) { return JSON.parse(JSON.stringify(strokesArray)); }
        function saveStateForUndo() {
            redoStack = []; historyStack.push(deepCopyStrokes(strokes));
            if (historyStack.length > MAX_HISTORY_STATES) { historyStack.shift(); }
            updateUndoRedoButtons();
        }
        function undo() {
            if (historyStack.length === 0) return;
            redoStack.push(deepCopyStrokes(strokes)); strokes = historyStack.pop();
            hideSelection(); redrawCanvas(); updateUndoRedoButtons();
        }
        function redo() {
            if (redoStack.length === 0) return;
            historyStack.push(deepCopyStrokes(strokes)); strokes = redoStack.pop();
            hideSelection(); redrawCanvas(); updateUndoRedoButtons();
        }
        function updateUndoRedoButtons() {
            undoButton.disabled = historyStack.length === 0; redoButton.disabled = redoStack.length === 0;
        }

        // ------------------ 獨立設定值管理 ------------------
        function getCurrentSettingKey() {
            if (currentTool === 'pen') return currentBrushType;
            if (currentTool === 'eraser') return currentEraseMode;
            return null;
        }
        function loadSettings(key) {
            if (!key || !toolSettings[key]) return;
            const settings = toolSettings[key];
            if (settings.color && currentColor !== settings.color) { previousColor = currentColor; currentColor = settings.color; }
            currentBrushSize = settings.size; currentOpacity = settings.opacity;
            colorPreview.style.backgroundColor = currentColor;
            brushSizeInput.value = currentBrushSize; sizeValueSpan.textContent = currentBrushSize;
            const opacityPercent = Math.round(currentOpacity * 100);
            opacityRangeInput.value = opacityPercent; opacityValueSpan.textContent = `${opacityPercent}%`;
        }
        function saveCurrentSettings(key) {
            if (!key || !toolSettings[key]) return;
            if (key !== 'round' && key !== 'rect_delete') {
                toolSettings[key].color = currentColor; toolSettings[key].size = currentBrushSize; toolSettings[key].opacity = currentOpacity;
            } else {
                toolSettings[key].size = currentBrushSize;
            }
        }

        // ------------------ 輔助函數 ------------------
        lucide.createIcons();
        function getTransformedPoint(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            return { x: (clientX - rect.left - canvasOffsetX) / scale, y: (clientY - rect.top - canvasOffsetY) / scale };
        }
        function getLineWidth(size, mode, pressure = 1, pointerType = 'mouse', forCursor = false) {
            if (forCursor) return size;
            if (mode === 'ballpoint' || mode === 'round' || mode === 'highlighter') { return (mode === 'highlighter') ? Math.max(1, size * 1.5) : Math.max(1, size); }
            if (mode === 'fountain') { let calculatedSize = size; if (pointerType === 'pen') { calculatedSize = size * (0.2 + Math.max(0, pressure || 0) * 1.2); } return Math.max(1, calculatedSize); }
            return size;
        }
        function isPointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y; const xj = polygon[j].x, yj = polygon[j].y;
                if (((yi > point.y) !== (yj > point.y)) && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi)) { inside = !inside; }
            }
            return inside;
        }
        function isStrokeIntersectingRect(stroke, rectMinX, rectMinY, rectMaxX, rectMaxY) {
            if (stroke.points.length === 0) return false;
            let strokeMinX = Infinity, strokeMinY = Infinity, strokeMaxX = -Infinity, strokeMaxY = -Infinity;
            for (const p of stroke.points) { strokeMinX = Math.min(strokeMinX, p.x); strokeMinY = Math.min(strokeMinY, p.y); strokeMaxX = Math.max(strokeMaxX, p.x); strokeMaxY = Math.max(strokeMaxY, p.y); }
            if (strokeMaxX < rectMinX || strokeMinX > rectMaxX || strokeMaxY < rectMinY || strokeMinY > rectMaxY) { return false; }
            for(const p of stroke.points) { if (p.x >= rectMinX && p.x <= rectMaxX && p.y >= rectMinY && p.y <= rectMaxY) { return true; } }
            return false;
        }
        
        // ------------------ 畫布與筆畫繪製 ------------------
        function drawStrokeSegmented(stroke) {
            if (stroke.points.length < 2) return;
            const isProblemCase = (stroke.brushType === 'highlighter') && stroke.opacity < 1.0;
            const targetCtx = isProblemCase ? offscreenCtx : ctx; const targetAlpha = isProblemCase ? 1.0 : stroke.opacity;
            if (isProblemCase) { offscreenCtx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height); }
            targetCtx.globalCompositeOperation = stroke.composite || 'source-over'; targetCtx.strokeStyle = stroke.color; targetCtx.lineCap = 'round'; targetCtx.lineJoin = 'round'; targetCtx.globalAlpha = targetAlpha;
            if (stroke.brushType !== 'fountain') {
                targetCtx.lineWidth = getLineWidth(stroke.size, stroke.brushType, 1, stroke.pointerType, false);
                targetCtx.beginPath(); targetCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
                for (let i = 1; i < stroke.points.length; i++) targetCtx.lineTo(stroke.points[i].x, stroke.points[i].y);
                targetCtx.stroke();
            } else {
                for (let i = 1; i < stroke.points.length; i++) {
                    const p1 = stroke.points[i - 1]; const p2 = stroke.points[i];
                    targetCtx.lineWidth = getLineWidth(stroke.size, stroke.brushType, p2.p || 1, stroke.pointerType, false);
                    targetCtx.beginPath(); targetCtx.moveTo(p1.x, p1.y); targetCtx.lineTo(p2.x, p2.y); targetCtx.stroke();
                }
            }
            if (isProblemCase) { ctx.globalAlpha = stroke.opacity; ctx.globalCompositeOperation = 'source-over'; ctx.drawImage(offscreenCanvas, 0, 0); ctx.globalAlpha = 1.0; }
        }
        
        function redrawCanvas() {
            ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.setTransform(scale, 0, 0, scale, canvasOffsetX, canvasOffsetY);
            strokes.forEach(stroke => drawStrokeSegmented(stroke));
            if (isDrawing && recordingPath.length > 1) {
                const pointerEvent = activePointers.values().next().value; const pointerType = pointerEvent ? pointerEvent.pointerType : 'mouse';
                const toolMode = (currentTool === 'eraser' && currentEraseMode === 'round') ? 'round' : currentBrushType; const isEraser = (toolMode === 'round' && currentTool === 'eraser');
                drawStrokeSegmented({ points: recordingPath, size: currentBrushSize, color: currentColor, brushType: toolMode, pointerType: pointerType, opacity: isEraser ? 1.0 : currentOpacity, composite: isEraser ? 'destination-out' : 'source-over' });
            }
            if ((isSelecting && lassoPath.length > 1) || (selectionActive && selectionBoundaryPolygon) || isRectSelecting) {
                ctx.strokeStyle = SELECTION_BLUE; ctx.lineWidth = 2 / scale; ctx.setLineDash([6 / scale, 3 / scale]); ctx.globalCompositeOperation = 'source-over'; ctx.globalAlpha = 1.0; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                if (currentTool === 'select') {
                    const path = isSelecting ? lassoPath : selectionBoundaryPolygon;
                    if (path && path.length > 1) { ctx.beginPath(); ctx.moveTo(path[0].x, path[0].y); for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y); if (selectionActive) ctx.closePath(); ctx.stroke(); }
                } else if (isRectSelecting && rectStartPoint && rectCurrentPoint) { const w = rectCurrentPoint.x - rectStartPoint.x; const h = rectCurrentPoint.y - rectStartPoint.y; ctx.strokeRect(rectStartPoint.x, rectStartPoint.y, w, h); }
                ctx.setLineDash([]);
            }
            ctx.globalCompositeOperation = 'source-over'; ctx.globalAlpha = 1.0;
        }

        function resizeCanvas() {
            const rect = container.getBoundingClientRect(); canvas.width = rect.width; canvas.height = rect.height; offscreenCanvas.width = rect.width; offscreenCanvas.height = rect.height;
            redrawCanvas();
        }
        async function clearCanvas() {
            const confirmed = await showCustomConfirm("清除所有繪圖", "此操作將會永久刪除畫布上的所有內容且無法復原。您確定要繼續嗎？");
            if (confirmed) {
                isDrawing = isSelecting = isMovingSelected = isRectSelecting = false; recordingPath = []; lassoPath = []; activePointers.clear(); strokes = []; historyStack = []; redoStack = []; scale = 1.0; canvasOffsetX = 0; canvasOffsetY = 0;
                hideSelection(); updateZoomIndicator(); updateUndoRedoButtons();
            }
        }

        function startDrawing(point, pressure, pointerType) { isDrawing = true; recordingPath = [{ x: point.x, y: point.y, p: pressure }]; }
        function updateDrawing(point, pressure = 1, pointerType = 'mouse') { if (!isDrawing) return; recordingPath.push({ x: point.x, y: point.y, p: pressure }); redrawCanvas(); }
        function finishStroke(pointerType) {
            if (recordingPath.length < 2) { recordingPath = []; return; }
            const toolMode = (currentTool === 'eraser' && currentEraseMode === 'round') ? 'round' : currentBrushType; const isEraser = (toolMode === 'round' && currentTool === 'eraser');
            saveStateForUndo();
            if (isEraser) {
                const eraserPath = recordingPath; const eraserSize = currentBrushSize; const nextStrokes = [];
                strokes.forEach(paintStroke => {
                    const newSegments = []; let currentSegment = []; let wasSplit = false;
                    for (const point of paintStroke.points) {
                        let isPointErased = false;
                        for (const eraserPoint of eraserPath) { const dist = Math.hypot(point.x - eraserPoint.x, point.y - eraserPoint.y); if (dist < eraserSize / 2) { isPointErased = true; break; } }
                        if (!isPointErased) { currentSegment.push(point); }
                        else { wasSplit = true; if (currentSegment.length > 1) { newSegments.push(currentSegment); } currentSegment = []; }
                    }
                    if (currentSegment.length > 0) { newSegments.push(currentSegment); }
                    if (wasSplit) { newSegments.forEach(segment => { if (segment.length > 1) { nextStrokes.push({ ...paintStroke, points: segment, id: Date.now() + Math.random() }); } }); }
                    else { nextStrokes.push(paintStroke); }
                });
                strokes = nextStrokes;
            } else { strokes.push({ id: Date.now() + Math.random(), points: recordingPath, size: currentBrushSize, color: currentColor, brushType: toolMode, tool: currentTool, pointerType: pointerType, selected: false, opacity: currentOpacity, composite: 'source-over' }); }
            recordingPath = []; redrawCanvas();
        }

        function startLasso(point) { hideSelection(); isSelecting = true; lassoPath = [point]; }
        function updateLasso(point) { if (isSelecting) { lassoPath.push(point); redrawCanvas(); } }
        function finishLasso() {
            isSelecting = false; if (lassoPath.length < 3) { lassoPath = []; redrawCanvas(); return; }
            const lassoBoundary = [...lassoPath]; lassoPath = []; let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; let selectedFound = false; selectedStrokes.clear();
            strokes.forEach(stroke => {
                const isSelected = stroke.points.some(p => isPointInPolygon(p, lassoBoundary)); stroke.selected = isSelected;
                if (isSelected) { selectedFound = true; selectedStrokes.add(stroke.id); stroke.points.forEach(p => { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); }); }
            });
            if (selectedFound) { selectionActive = true; selectionBoundaryPolygon = lassoBoundary; selectionBounds = { x: minX, y: minY, width: maxX - minX, height: maxY - minY }; updateSelectionControlsPosition(); canvas.style.cursor = 'move'; }
            else { hideSelection(); }
            redrawCanvas();
        }
        function hideSelection() {
            selectionActive = isSelecting = false; selectedStrokes.clear(); selectionBoundaryPolygon = selectionBounds = null; strokes.forEach(s => s.selected = false);
            selectionControls.style.display = 'none'; redrawCanvas(); if (currentTool === 'select') canvas.style.cursor = 'crosshair';
        }
        function deleteSelectedStrokes() { saveStateForUndo(); strokes = strokes.filter(s => !s.selected); hideSelection(); }
        function copySelectedStrokes() {
            saveStateForUndo(); const OFFSET = 15 / scale;
            const newStrokes = strokes.filter(s => s.selected).map(s => { s.selected = false; return { ...s, id: Date.now() + Math.random(), selected: true, points: s.points.map(p => ({ ...p, x: p.x + OFFSET, y: p.y + OFFSET }))}; });
            strokes.push(...newStrokes); selectedStrokes.clear(); newStrokes.forEach(s => selectedStrokes.add(s.id));
            if (selectionBoundaryPolygon) selectionBoundaryPolygon = selectionBoundaryPolygon.map(p => ({ x: p.x + OFFSET, y: p.y + OFFSET }));
            recalculateSelectionBounds(); redrawCanvas();
        }
        function recalculateSelectionBounds() {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity; const selectedFound = strokes.some(s => s.selected);
            if (selectedFound) { strokes.forEach(s => { if (s.selected) s.points.forEach(p => { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); }); }); selectionBounds = { x: minX, y: minY, width: maxX - minX, height: maxY - minY }; updateSelectionControlsPosition(); }
            else { hideSelection(); }
        }
        function updateSelectionControlsPosition() {
            if (!selectionBounds) { selectionControls.style.display = 'none'; return; }
            const worldCenterX = selectionBounds.x + selectionBounds.width / 2; const worldBottomY = selectionBounds.y + selectionBounds.height;
            const screenX = worldCenterX * scale + canvasOffsetX; const screenY = worldBottomY * scale + canvasOffsetY;
            selectionControls.style.left = `${screenX}px`; selectionControls.style.top = `${screenY}px`;
            selectionControls.style.transform = 'translateX(-50%) translateY(10px)'; selectionControls.style.display = 'flex';
        }
        function isPointInSelectionBounds(point, bounds) {
            const padding = 20 / scale;
            return point.x >= bounds.x - padding && point.x <= bounds.x + bounds.width + padding && point.y >= bounds.y - padding && point.y <= bounds.y + bounds.height + padding;
        }
        let startMovePoint = null;
        function startMove(point) { saveStateForUndo(); isMovingSelected = true; startMovePoint = point; canvas.style.cursor = 'grabbing'; selectionControls.style.display = 'none'; }
        function updateMove(point) {
            if (!isMovingSelected) return; const dx = point.x - startMovePoint.x; const dy = point.y - startMovePoint.y; startMovePoint = point;
            strokes.forEach(s => { if (s.selected) s.points.forEach(p => { p.x += dx; p.y += dy; }); });
            if (selectionBoundaryPolygon) selectionBoundaryPolygon.forEach(p => { p.x += dx; p.y += dy; });
            if (selectionBounds) { selectionBounds.x += dx; selectionBounds.y += dy; }
            redrawCanvas();
        }
        function endMove() { isMovingSelected = false; startMovePoint = null; recalculateSelectionBounds(); canvas.style.cursor = 'move'; }

        function startRectSelect(point) { isRectSelecting = true; rectStartPoint = rectCurrentPoint = point; canvas.style.cursor = 'crosshair'; }
        function updateRectSelect(point) { if (isRectSelecting) { rectCurrentPoint = point; redrawCanvas(); } }
        function executeRectDelete() {
            isRectSelecting = false; canvas.style.cursor = 'default'; if (!rectStartPoint || !rectCurrentPoint) { redrawCanvas(); return; }
            saveStateForUndo(); const minX = Math.min(rectStartPoint.x, rectCurrentPoint.x); const minY = Math.min(rectStartPoint.y, rectCurrentPoint.y);
            const maxX = Math.max(rectStartPoint.x, rectCurrentPoint.x); const maxY = Math.max(rectStartPoint.y, rectCurrentPoint.y);
            strokes = strokes.filter(stroke => !isStrokeIntersectingRect(stroke, minX, minY, maxX, maxY));
            rectStartPoint = rectCurrentPoint = null; redrawCanvas();
        }

        function updateBrushCursor(e) {
            if (isPalmRejectionEnabled && e.pointerType === 'touch') { brushCursor.style.display = 'none'; return; }
            const isBrushOrRoundEraser = currentTool === 'pen' || (currentTool === 'eraser' && currentEraseMode === 'round');
            if (!isBrushOrRoundEraser) { brushCursor.style.display = 'none'; return; }
            const containerRect = container.getBoundingClientRect(); const relX = e.clientX - containerRect.left; const relY = e.clientY - containerRect.top;
            const toolMode = (currentTool === 'eraser') ? 'round' : currentBrushType; const size = getLineWidth(currentBrushSize, toolMode, 1, e.pointerType, true);
            brushCursor.style.width = `${size * scale}px`; brushCursor.style.height = `${size * scale}px`; brushCursor.style.left = `${relX}px`; brushCursor.style.top = `${relY}px`; brushCursor.style.display = 'block';
            if (currentTool === 'eraser') { brushCursor.style.borderColor = `rgba(0, 0, 0, 0.6)`; brushCursor.style.backgroundColor = `rgba(255, 255, 255, 0.2)`; }
            else { const { r, g, b } = hexToRgb(currentColor); brushCursor.style.borderColor = currentColor; brushCursor.style.backgroundColor = `rgba(${r}, ${g}, ${b}, 0.2)`; }
        }
        function hideBrushCursor() { brushCursor.style.display = 'none'; }
        
        function updateZoomIndicator() {
            if (zoomTimeout) clearTimeout(zoomTimeout);
            zoomIndicator.textContent = `${Math.round(scale * 100)}%`;
            zoomIndicator.style.opacity = '1';
            zoomTimeout = setTimeout(() => { zoomIndicator.style.opacity = '0'; }, 2000);
        }
        
        function getPointersDistance(pointers) {
            const p1 = pointers[0]; const p2 = pointers[1];
            return Math.hypot(p1.clientX - p2.clientX, p1.clientY - p2.clientY);
        }
        function handlePanAndZoom() {
            if (activePointers.size < 2) return;
            const pointers = Array.from(activePointers.values());
            const newMidPoint = { x: (pointers[0].clientX + pointers[1].clientX) / 2, y: (pointers[0].clientY + pointers[1].clientY) / 2 };
            const newPinchDistance = getPointersDistance(pointers);
            const panDx = newMidPoint.x - initialMidPoint.x; const panDy = newMidPoint.y - initialMidPoint.y;
            canvasOffsetX += panDx; canvasOffsetY += panDy;
            const rect = canvas.getBoundingClientRect(); const mouseX = newMidPoint.x - rect.left; const mouseY = newMidPoint.y - rect.top;
            const worldX = (mouseX - canvasOffsetX) / scale; const worldY = (mouseY - canvasOffsetY) / scale;
            const scaleMultiplier = newPinchDistance / initialPinchDistance; const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * scaleMultiplier));
            canvasOffsetX = mouseX - worldX * newScale; canvasOffsetY = mouseY - worldY * newScale; scale = newScale;
            initialMidPoint = newMidPoint; initialPinchDistance = newPinchDistance;
            redrawCanvas(); updateSelectionControlsPosition(); updateZoomIndicator();
        }

        function initializePanAndZoom() {
            const pointers = Array.from(activePointers.values());
            if (pointers.length < 2) return;
            initialPinchDistance = getPointersDistance(pointers);
            initialMidPoint = { x: (pointers[0].clientX + pointers[1].clientX) / 2, y: (pointers[0].clientY + pointers[1].clientY) / 2 };
        }
        canvas.addEventListener('pointerdown', (e) => {
            e.preventDefault(); canvas.setPointerCapture(e.pointerId); activePointers.set(e.pointerId, e);
            if (activePointers.size >= 2) { isDrawing = isSelecting = isMovingSelected = isRectSelecting = false; isPanningOrZooming = true; hideSelection(); initializePanAndZoom(); canvas.style.cursor = 'grabbing'; return; }
            const transformedPoint = getTransformedPoint(e.clientX, e.clientY);
            const isPenOrMouse = (e.pointerType === 'pen' || e.pointerType === 'mouse'); const isTouch = e.pointerType === 'touch';
            if (isPenOrMouse || (isTouch && !isPalmRejectionEnabled)) {
                isPanningOrZooming = false;
                if (currentTool === 'pen') { hideSelection(); startDrawing(transformedPoint, e.pressure || 1, e.pointerType); }
                else if (currentTool === 'eraser') { hideSelection(); if (currentEraseMode === 'round') startDrawing(transformedPoint, e.pressure || 1, e.pointerType); else if (currentEraseMode === 'rect_delete') startRectSelect(transformedPoint); }
                else if (currentTool === 'select') { if (selectionActive && selectionBounds && isPointInSelectionBounds(transformedPoint, selectionBounds)) { startMove(transformedPoint); } else { startLasso(transformedPoint); } }
            }
        });
        canvas.addEventListener('pointermove', (e) => {
            e.preventDefault(); if (!activePointers.has(e.pointerId)) return;
            activePointers.set(e.pointerId, e); updateBrushCursor(e);
            if (isPanningOrZooming) { handlePanAndZoom(); }
            else if (isDrawing) { updateDrawing(getTransformedPoint(e.clientX, e.clientY), e.pressure || 1, e.pointerType); }
            else if (isMovingSelected) { updateMove(getTransformedPoint(e.clientX, e.clientY)); }
            else if (isSelecting) { updateLasso(getTransformedPoint(e.clientX, e.clientY)); }
            else if (isRectSelecting) { updateRectSelect(getTransformedPoint(e.clientX, e.clientY)); }
        });
        function stopInteraction(e) {
            canvas.releasePointerCapture(e.pointerId); const wasPanningOrZooming = isPanningOrZooming;
            activePointers.delete(e.pointerId);
            if (wasPanningOrZooming && activePointers.size < 2) { isPanningOrZooming = false; canvas.style.cursor = 'default'; redrawCanvas(); }
            else if (wasPanningOrZooming) { initializePanAndZoom(); }
            if (!wasPanningOrZooming) {
                if (isDrawing) finishStroke(e.pointerType);
                else if (isSelecting) finishLasso();
                else if (isMovingSelected) endMove();
                else if (isRectSelecting) executeRectDelete();
            }
            isDrawing = isSelecting = isMovingSelected = false; hideBrushCursor();
        }
        canvas.addEventListener('pointerup', stopInteraction);
        canvas.addEventListener('pointercancel', stopInteraction);
        canvas.addEventListener('pointerout', (e) => { if (activePointers.has(e.pointerId)) stopInteraction(e); });

        // ------------------ 工具列事件處理 ------------------
        function setActiveTool(tool) {
            if (currentTool === tool) return; const oldKey = getCurrentSettingKey(); if (oldKey) saveCurrentSettings(oldKey);
            currentTool = tool; document.querySelectorAll('#mainTools button').forEach(btn => btn.classList.remove('active')); document.getElementById(`tool_${tool}`).classList.add('active');
            hideSelection(); isRectSelecting = false; rectStartPoint = null; rectCurrentPoint = null;
            brushOptionsDiv.classList.toggle('hidden', tool !== 'pen'); eraseControlsDiv.classList.toggle('hidden', tool !== 'eraser');
            const drawingSettingsDiv = document.getElementById('drawingSettings');
            if (tool === 'select') { drawingSettingsDiv.classList.add('hidden'); }
            else { drawingSettingsDiv.classList.remove('hidden'); }
            const isPenTool = (tool === 'pen');
            colorContainer.classList.toggle('hidden', !isPenTool); opacityContainer.classList.toggle('hidden', !isPenTool);
            loadSettings(getCurrentSettingKey()); redrawCanvas();
            if (tool === 'select' || (tool === 'eraser' && currentEraseMode === 'rect_delete')) { canvas.style.cursor = 'crosshair'; }
            else if (tool === 'pen' || (tool === 'eraser' && currentEraseMode === 'round')) { canvas.style.cursor = 'none'; }
            else { canvas.style.cursor = 'default'; }
        }
        
        function handleStylusAction(action) {
            if (action === 'none') return;
            switch(action) {
                case 'eraser': setActiveTool(currentTool === 'eraser' ? 'pen' : 'eraser'); break;
                case 'select': setActiveTool(currentTool === 'select' ? 'pen' : 'select'); break;
                case 'previousColor':
                    const temp = currentColor; currentColor = previousColor; previousColor = temp; colorPreview.style.backgroundColor = currentColor;
                    const key = getCurrentSettingKey(); if (key && toolSettings[key] && 'color' in toolSettings[key]) { toolSettings[key].color = currentColor; }
                    redrawCanvas(); break;
            }
        }
        document.addEventListener('keydown', (e) => {
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT') return;
            if (e.keyCode === 34) { e.preventDefault(); handleStylusAction(primaryButtonAction); }
            else if (e.keyCode === 33) { e.preventDefault(); handleStylusAction(secondaryButtonAction); }
        });
        settingsButton.addEventListener('click', () => { stylusSettingsModal.style.display = 'flex'; });
        saveSettingsBtn.addEventListener('click', () => { primaryButtonAction = primaryButtonSelect.value; secondaryButtonAction = secondaryButtonSelect.value; stylusSettingsModal.style.display = 'none'; });
        
        window.addEventListener('load', () => { resizeCanvas(); setActiveTool('pen'); updateUndoRedoButtons(); initializeColorPicker(); });
        window.addEventListener('resize', resizeCanvas);
        clearButton.addEventListener('click', clearCanvas);
        undoButton.addEventListener('click', undo);
        redoButton.addEventListener('click', redo);
        document.querySelectorAll('#mainTools button').forEach(btn => btn.addEventListener('click', () => setActiveTool(btn.dataset.tool)));
        document.querySelectorAll('#brushOptions button').forEach(btn => {
            btn.addEventListener('click', () => {
                const oldKey = currentBrushType; if (oldKey) saveCurrentSettings(oldKey); currentBrushType = btn.dataset.brush;
                btn.parentElement.querySelectorAll('button').forEach(b => b.classList.remove('active')); btn.classList.add('active'); loadSettings(currentBrushType);
            });
        });
        document.querySelectorAll('#eraseControls button').forEach(btn => {
            btn.addEventListener('click', () => {
                const oldKey = currentEraseMode; if (oldKey) saveCurrentSettings(oldKey); currentEraseMode = btn.dataset.eraser;
                btn.parentElement.querySelectorAll('button').forEach(b => b.classList.remove('active')); btn.classList.add('active'); loadSettings(currentEraseMode); setActiveTool(currentTool);
            });
        });
        document.getElementById('deleteSelectionBtn').addEventListener('click', deleteSelectedStrokes);
        document.getElementById('copySelectionBtn').addEventListener('click', copySelectedStrokes);
        brushSizeInput.addEventListener('input', (e) => {
            currentBrushSize = parseInt(e.target.value); sizeValueSpan.textContent = currentBrushSize; const key = getCurrentSettingKey(); if (key) toolSettings[key].size = currentBrushSize;
        });
        opacityRangeInput.addEventListener('input', (e) => {
            currentOpacity = parseInt(e.target.value) / 100; opacityValueSpan.textContent = `${parseInt(e.target.value)}%`; const key = getCurrentSettingKey(); if (key) toolSettings[key].opacity = currentOpacity;
        });
        palmRejectionToggle.addEventListener('change', (e) => { isPalmRejectionEnabled = e.target.checked; });
    </script>
</body>
</html>
