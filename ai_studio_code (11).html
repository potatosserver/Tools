<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>WebHID API 觸控筆按鈕偵測實驗</title>
<style>
  body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; padding-top: 20px; }
  button { font-size: 1.2em; padding: 10px 20px; margin-bottom: 20px; cursor: pointer; }
  #status { font-size: 1.1em; color: #333; height: 30px; }
  #report-display {
    font-family: monospace;
    white-space: pre;
    background-color: #f0f0f0;
    border: 1px solid #ccc;
    padding: 15px;
    min-height: 100px;
    width: 80%;
    max-width: 600px;
    margin-top: 20px;
  }
</style>
</head>
<body>

  <h1>WebHID 觸控筆按鈕偵測實驗</h1>
  <button id="connect-hid">1. 連接觸控筆設備</button>
  <div id="status">狀態：尚未連接</div>
  <div id="report-display">等待輸入報告...</div>

<script>
  const connectButton = document.getElementById('connect-hid');
  const statusDisplay = document.getElementById('status');
  const reportDisplay = document.getElementById('report-display');

  // 檢查瀏覽器是否支援 WebHID
  if (!("hid" in navigator)) {
    connectButton.disabled = true;
    statusDisplay.textContent = "錯誤：您的瀏覽器不支援 WebHID API。";
  }

  let myDevice = null;

  connectButton.addEventListener('click', async () => {
    statusDisplay.textContent = "正在等待使用者選擇設備...";
    try {
      // 請求存取設備。這裡的 filters 很重要。
      // 我們使用 Usage Page 和 Usage ID 來過濾出通用型的觸控筆/數位板設備。
      // 0x0D = Digitizers, 0x01 = Digitizer, 0x02 = Pen, 0x05 = Touch Screen
      const devices = await navigator.hid.requestDevice({
        filters: [
          { usagePage: 0x0D, usage: 0x01 },
          { usagePage: 0x0D, usage: 0x02 },
          { usagePage: 0x0D, usage: 0x05 },
        ],
      });

      if (!devices.length) {
        statusDisplay.textContent = "狀態：沒有選擇任何設備。";
        return;
      }

      // 取得選擇的第一個設備
      myDevice = devices[0];
      statusDisplay.textContent = `準備連接到：${myDevice.productName}...`;

      // 打開與設備的連接
      await myDevice.open();
      statusDisplay.textContent = `已連接到：${myDevice.productName}！請操作您的觸控筆。`;
      connectButton.disabled = true; // 連接成功後禁用按鈕

      // *** 核心：監聽來自設備的輸入報告 ***
      myDevice.addEventListener("inputreport", event => {
        handleInputReport(event);
      });

    } catch (error) {
      statusDisplay.textContent = `發生錯誤：${error.message}`;
      console.error(error);
    }
  });

  function handleInputReport(event) {
    const { data, device, reportId } = event;

    // data 是一個 DataView 物件，包含了原始的二進位數據
    if (data.byteLength === 0) {
      // 忽略空的報告
      return;
    }

    // 將 DataView 中的數據轉換為一個十六進位字串陣列，方便觀察
    const reportBytes = [];
    for (let i = 0; i < data.byteLength; i++) {
      // getUint8(i) 讀取第 i 個位元組
      // .toString(16) 轉換為十六進位
      // .padStart(2, '0') 確保總是兩位數 (例如 5 變成 05)
      reportBytes.push(data.getUint8(i).toString(16).padStart(2, '0'));
    }

    let logText = `來自 ${device.productName} 的報告 (ID: ${reportId})\n`;
    logText += `-----------------------------------------\n`;
    logText += `原始數據 (HEX): ${reportBytes.join(' ')}\n\n`;

    // --- 在這裡添加您的解碼邏輯 ---
    // 範例：假設我們經過觀察，發現第4個位元組的第2個位元(0b00000010)代表按鈕
    // 注意：位元組索引是從 0 開始的
    if (data.byteLength > 3) {
        const buttonByte = data.getUint8(3); // 讀取第四個位元組
        logText += `正在分析第 4 個位元組: ${buttonByte} (0x${reportBytes[3]})\n`;

        // 使用位元運算 "&" 來檢查特定位元是否為 1
        if (buttonByte & 0b00000010) { // 檢查第二個位元 (值為 2)
            logText += `>>>>> 偵測到按鈕 A 按下！ <<<<<\n`;
        }
        if (buttonByte & 0b00000100) { // 檢查第三個位元 (值為 4)
            logText += `>>>>> 偵測到按鈕 B 按下！ <<<<<\n`;
        }
    }
    // ----------------------------

    reportDisplay.textContent = logText;
  }

</script>

</body>
</html>